<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android Arm Inline Hook · Ele7enxxh's Blog</title><meta name="description" content="Android Arm Inline Hook - ele7enxxh"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/5545520757" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/ele7enxxh" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android Arm Inline Hook</h1><div class="post-info">Jan 27, 2016</div><div class="post-content"><p>本文将结合<a href="https://github.com/ele7enxxh/Android-Inline-Hook" target="_blank" rel="external">本项目</a>的源代码，详细阐述Android Arm Inline Hook的原理与实现过程。<a id="more"></a></p>
<h2 id="什么是Inline-Hook"><a href="#什么是Inline-Hook" class="headerlink" title="什么是Inline Hook"></a>什么是Inline Hook</h2><p>Inline Hook即内部跳转Hook，通过替换函数开始处的指令为跳转指令，使得原函数跳转到自己的函数，通常还会保留原函数的调用接口。与GOT表Hook相比，Inline Hook具有更广泛的适用性，几乎可以Hook任何函数，不过其实现更为复杂，考虑的情况更多，并且无法对一些太短的函数Hook。<br>其基本原理请参阅网上其他资料。</p>
<h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><blockquote>
<ol>
<li>Arm模式与Thumb模式的区别</li>
<li>跳转指令的构造</li>
<li>PC相关指令的修正</li>
<li>线程处理</li>
<li>其他一些细节</li>
</ol>
</blockquote>
<p>下面我将结合源码对这几个问题进行解决。</p>
<h2 id="Arm模式与Thumb模式的区别"><a href="#Arm模式与Thumb模式的区别" class="headerlink" title="Arm模式与Thumb模式的区别"></a>Arm模式与Thumb模式的区别</h2><p>本文讨论的对象为基于32位的Arm架构的Inline Hook，在Arm版本7及以上的体系中，其指令集分为Arm指令集和Thumb指令集。Arm指令为4字节对齐，每条指令长度均为32位；Thumb指令为2字节对齐，又分为Thumb16、Thumb32，其中Thumb16指令长度为16位，Thumb32指令长度为32位。<br>在对一个函数进行Inline Hook时，首先需要判断当前函数指令是Arm指令还是Thumb指令，指令使用目标地址值的bit[0]来确定目标地址的指令类型。bit[0]的值为1时，目标程序为Thumb指令；bit[0]值为0时，目标程序为ARM指令。其相关实现代码为以下宏：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置bit[0]的值为1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_BIT0(addr)		(addr | 1)</span></span><br><span class="line"><span class="comment">// 设置bit[0]的值为0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLEAR_BIT0(addr)	(addr &amp; 0xFFFFFFFE)</span></span><br><span class="line"><span class="comment">// 测试bit[0]的值，若为1则返回真，若为0则返回假</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_BIT0(addr)		(addr &amp; 1)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="跳转指令的构造"><a href="#跳转指令的构造" class="headerlink" title="跳转指令的构造"></a>跳转指令的构造</h2><p>跳转指令主要分为以下两种：</p>
<blockquote>
<ul>
<li>B系列指令：B、BL、BX、BLX</li>
<li>直接写PC寄存器</li>
</ul>
</blockquote>
<p>Arm的B系列指令跳转范围只有4M，Thumb的B系列指令跳转范围只有256字节，然而大多数情况下跳转范围都会大于4M，故我们采用<code>LDR PC, [PC, ?]</code>构造跳转指令。另外Thumb16指令中并没有合适的跳转指令，如果单独使用Thumb16指令构造跳转指令，需要使用更多的指令完成，并且在后续对PC相关指令的修正也更加繁琐，故综合考虑下，决定放弃对ARMv5的支持。<br>另外，Arm处理器采用3级流水线来增加处理器指令流的速度，也就是说程序计数器R15(PC)总是指向“正在取指”的指令，而不是指向“正在执行”的，即PC总是指向当前正在执行的指令地址再加2条指令的地址。比如当前指令地址是0×8000， 那么当前pc的值，在thumb下面是0×8000 + 2 <em> 2， 在arm下面是0×8000 + 4 </em> 2。<br>对于Arm指令集，跳转指令为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR PC, [PC, #-4]</span><br><span class="line">addr</span><br></pre></td></tr></table></figure></p>
<p><code>LDR PC, [PC, #-4]</code>对应的机器码为：0xE51FF004，<code>addr</code>为要跳转的地址。该跳转指令范围为32位，对于32位系统来说即为全地址跳转。<br>对于Thumb32指令集，跳转指令为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR.W PC, [PC, #0]</span><br><span class="line">addr</span><br></pre></td></tr></table></figure></p>
<p><code>LDR.W PC, [PC, #0]</code>对应的机器码为：0x00F0DFF8，<code>addr</code>为要跳转的地址。同样支持任意地址跳转。<br>其相关实现代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Arm Mode</span></span><br><span class="line"><span class="keyword">if</span> (TEST_BIT0(item-&gt;target_addr)) &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (CLEAR_BIT0(item-&gt;target_addr) % <span class="number">4</span> != <span class="number">0</span>) &#123;</span><br><span class="line">		((<span class="keyword">uint16_t</span> *) CLEAR_BIT0(item-&gt;target_addr))[i++] = <span class="number">0xBF00</span>;  <span class="comment">// NOP</span></span><br><span class="line">	&#125;</span><br><span class="line">	((<span class="keyword">uint16_t</span> *) CLEAR_BIT0(item-&gt;target_addr))[i++] = <span class="number">0xF8DF</span>;</span><br><span class="line">	((<span class="keyword">uint16_t</span> *) CLEAR_BIT0(item-&gt;target_addr))[i++] = <span class="number">0xF000</span>;	<span class="comment">// LDR.W PC, [PC]</span></span><br><span class="line">	((<span class="keyword">uint16_t</span> *) CLEAR_BIT0(item-&gt;target_addr))[i++] = item-&gt;new_addr &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">	((<span class="keyword">uint16_t</span> *) CLEAR_BIT0(item-&gt;target_addr))[i++] = item-&gt;new_addr &gt;&gt; <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Thumb Mode</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	((<span class="keyword">uint32_t</span> *) (item-&gt;target_addr))[<span class="number">0</span>] = <span class="number">0xe51ff004</span>;	<span class="comment">// LDR PC, [PC, #-4]</span></span><br><span class="line">	((<span class="keyword">uint32_t</span> *) (item-&gt;target_addr))[<span class="number">1</span>] = item-&gt;new_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先通过TEST_BIT0宏判断目标函数的指令集类型，其中若为Thumb指令集，多了下面一个额外处理：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CLEAR_BIT0(item-&gt;target_addr) % <span class="number">4</span> != <span class="number">0</span>) &#123;</span><br><span class="line">	((<span class="keyword">uint16_t</span> *) CLEAR_BIT0(item-&gt;target_addr))[i++] = <span class="number">0xBF00</span>;  <span class="comment">// NOP</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对bit[0]的值清零，若其值4字节不对齐，则添加一个2字节的<code>NOP</code>指令，使得后续的指令4字节对齐。这是因为在Thumb32指令中，若该指令对PC寄存器的值进行了修改，则该指令必须是4字节对齐的，否则为非法指令。</p>
<h2 id="PC相关指令的修正"><a href="#PC相关指令的修正" class="headerlink" title="PC相关指令的修正"></a>PC相关指令的修正</h2><p>不论是Arm指令集还是Thumb指令集，都存在很多的与PC值相关的指令，例如：B系列指令、literal系列指令等。原有函数的前几个被跳转指令替换的指令将会被搬移到trampoline_instructions中，此时PC值已经变动，所以需要对PC相关指令进行修正（所谓修正即为计算出实际地址，并使用其他指令完成同样的功能）。相关修正代码位于relocate.c文件中。其中<code>INSTRUCTION_TYPE</code>描述了需要修正的指令，限于篇幅，这里仅阐述Arm指令的修正过程，对应的代码为<code>relocateInstructionInArm</code>函数。<br>函数原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">target_addr: 待Hook的目标函数地址，即为当前PC值，用于修正指令</span><br><span class="line">orig_instructions：存放原有指令的首地址，用于修正指令和后续对原有指令的恢复</span><br><span class="line">length：存放的原有指令的长度，Arm指令为8字节；Thumb指令为12字节</span><br><span class="line">trampoline_instructions：存放修正后指令的首地址，用于调用原函数</span><br><span class="line">orig_boundaries：存放原有指令的指令边界（所谓边界即为该条指令与起始地址的偏移量），用于后续线程处理中，对PC的迁移</span><br><span class="line">trampoline_boundaries：存放修正后指令的指令边界，用途与上相同</span><br><span class="line">count：处理的指令项数，用途与上相同</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">relocateInstructionInArm</span><span class="params">(<span class="keyword">uint32_t</span> target_addr, <span class="keyword">uint32_t</span> *orig_instructions, <span class="keyword">int</span> length, <span class="keyword">uint32_t</span> *trampoline_instructions, <span class="keyword">int</span> *orig_boundaries, <span class="keyword">int</span> *trampoline_boundaries, <span class="keyword">int</span> *count)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>具体实现中，首先通过函数<code>getTypeInArm</code>判断当前指令的类型，本函数通过类型，共分为4个处理分支：</p>
<blockquote>
<ol>
<li>BLX_ARM、BL_ARM、B_ARM、BX_ARM</li>
<li>ADD_ARM</li>
<li>ADR1_ARM、ADR2_ARM、LDR_ARM、MOV_ARM</li>
<li>其他指令</li>
</ol>
</blockquote>
<h3 id="BLX-ARM、BL-ARM、B-ARM、BX-ARM指令的修正"><a href="#BLX-ARM、BL-ARM、B-ARM、BX-ARM指令的修正" class="headerlink" title="BLX_ARM、BL_ARM、B_ARM、BX_ARM指令的修正"></a>BLX_ARM、BL_ARM、B_ARM、BX_ARM指令的修正</h3><p>即为B系列指令（<code>BLX &lt;label&gt;</code>、<code>BL &lt;label&gt;</code>、<code>B &lt;label&gt;</code>、<code>BX PC</code>）的修正，其中<code>BLX_ARM</code>和<code>BL_ARM</code>需要修正LR寄存器的值，相关代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (type == BLX_ARM || type == BL_ARM) &#123;</span><br><span class="line">	trampoline_instructions[trampoline_pos++] = <span class="number">0xE28FE004</span>;	<span class="comment">// ADD LR, PC, #4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来构造相应的跳转指令，即为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE51FF004</span>;  	<span class="comment">// LDR PC, [PC, #-4]</span></span><br></pre></td></tr></table></figure></p>
<p>最后解析指令，计算实际跳转地址<code>value</code>，并将其写入<code>trampoline_instructions</code>，相关代码为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (type == BLX_ARM) &#123;</span><br><span class="line">	x = ((instruction &amp; <span class="number">0xFFFFFF</span>) &lt;&lt; <span class="number">2</span>) | ((instruction &amp; <span class="number">0x1000000</span>) &gt;&gt; <span class="number">23</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == BL_ARM || type == B_ARM) &#123;</span><br><span class="line">	x = (instruction &amp; <span class="number">0xFFFFFF</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">top_bit = x &gt;&gt; <span class="number">25</span>;</span><br><span class="line">imm32 = top_bit ? (x | (<span class="number">0xFFFFFFFF</span> &lt;&lt; <span class="number">26</span>)) : x;</span><br><span class="line"><span class="keyword">if</span> (type == BLX_ARM) &#123;</span><br><span class="line">	value = pc + imm32 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	value = pc + imm32;</span><br><span class="line">&#125;</span><br><span class="line">trampoline_instructions[trampoline_pos++] = value;</span><br></pre></td></tr></table></figure></p>
<p>如此便完成了B系列指令的修正，关于指令的字节结构请参考Arm指令手册。</p>
<h3 id="ADD-ARM指令的修正"><a href="#ADD-ARM指令的修正" class="headerlink" title="ADD_ARM指令的修正"></a>ADD_ARM指令的修正</h3><p><code>ADD_ARM</code>指的是<code>ADR Rd, &lt;label&gt;</code>格式的指令，其中<code>&lt;label&gt;</code>与PC相关。<br>首先通过循环遍历，得到Rd寄存器，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rd;</span><br><span class="line"><span class="keyword">int</span> rm;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析指令得到rd、rm寄存器</span></span><br><span class="line">rd = (instruction &amp; <span class="number">0xF000</span>) &gt;&gt; <span class="number">12</span>;</span><br><span class="line">rm = instruction &amp; <span class="number">0xF</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为避免冲突，排除rd、rm寄存器，选择一个临时寄存器Rr</span></span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">12</span>; ; --r) &#123;</span><br><span class="line">	<span class="keyword">if</span> (r != rd &amp;&amp; r != rm) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来是构造修正指令：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PUSH &#123;Rr&#125;，保护Rr寄存器值</span></span><br><span class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE52D0004</span> | (r &lt;&lt; <span class="number">12</span>);</span><br><span class="line"><span class="comment">// LDR Rr, [PC, #8]，将PC值存入Rr寄存器中</span></span><br><span class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE59F0008</span> | (r &lt;&lt; <span class="number">12</span>);</span><br><span class="line"><span class="comment">// 变换原指令`ADR Rd, &lt;label&gt;`为`ADR Rd, Rr, ?`</span></span><br><span class="line">trampoline_instructions[trampoline_pos++] = (instruction &amp; <span class="number">0xFFF0FFFF</span>) | (r &lt;&lt; <span class="number">16</span>);</span><br><span class="line"><span class="comment">//POP &#123;Rr&#125;，恢复Rr寄存器值</span></span><br><span class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE49D0004</span> | (r &lt;&lt; <span class="number">12</span>);</span><br><span class="line"><span class="comment">// ADD PC, PC，跳过下一条指令</span></span><br><span class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE28FF000</span>;</span><br><span class="line">trampoline_instructions[trampoline_pos++] = pc;</span><br></pre></td></tr></table></figure></p>
<h3 id="ADR1-ARM、ADR2-ARM、LDR-ARM、MOV-ARM"><a href="#ADR1-ARM、ADR2-ARM、LDR-ARM、MOV-ARM" class="headerlink" title="ADR1_ARM、ADR2_ARM、LDR_ARM、MOV_ARM"></a>ADR1_ARM、ADR2_ARM、LDR_ARM、MOV_ARM</h3><p>分别为<code>ADR Rd, &lt;label&gt;</code>、<code>ADR Rd, &lt;label&gt;</code>、<code>LDR Rt, &lt;label&gt;</code>、<code>MOV Rd, PC</code>。<br>同样首先解析指令，得到<code>value</code>，相关代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">uint32_t</span> value;</span><br><span class="line"></span><br><span class="line">r = (instruction &amp; <span class="number">0xF000</span>) &gt;&gt; <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == ADR1_ARM || type == ADR2_ARM || type == LDR_ARM) &#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> imm32;</span><br><span class="line">	</span><br><span class="line">	imm32 = instruction &amp; <span class="number">0xFFF</span>;</span><br><span class="line">	<span class="keyword">if</span> (type == ADR1_ARM) &#123;</span><br><span class="line">		value = pc + imm32;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (type == ADR2_ARM) &#123;</span><br><span class="line">		value = pc - imm32;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (type == LDR_ARM) &#123;</span><br><span class="line">		<span class="keyword">int</span> is_add;</span><br><span class="line">		</span><br><span class="line">		is_add = (instruction &amp; <span class="number">0x800000</span>) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">		<span class="keyword">if</span> (is_add) &#123;</span><br><span class="line">			value = ((<span class="keyword">uint32_t</span> *) (pc + imm32))[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			value = ((<span class="keyword">uint32_t</span> *) (pc - imm32))[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	value = pc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后构造修正指令，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LDR Rr, [PC]</span></span><br><span class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE51F0000</span> | (r &lt;&lt; <span class="number">12</span>);</span><br><span class="line"><span class="comment">// 跳过下一条指令</span></span><br><span class="line">trampoline_instructions[trampoline_pos++] = <span class="number">0xE28FF000</span>;	<span class="comment">// ADD PC, PC</span></span><br><span class="line">trampoline_instructions[trampoline_pos++] = value;</span><br></pre></td></tr></table></figure></p>
<h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><p>事实上，还有些指令格式需要修正，例如：<code>PUSH {PC}</code>、<code>PUSH {SP}</code>等，虽然这些指令被Arm指令手册标记为<strong>deprecated</strong>，但是仍然为合法指令，不过在实际汇编中并未发现此类指令，故未做处理，相关代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接将指令存放到trampoline_instructions中</span></span><br><span class="line">trampoline_instructions[trampoline_pos++] = instruction;</span><br></pre></td></tr></table></figure></p>
<p>处理完所有待处理指令后，最后加入返回指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// LDR PC, [PC, #-4]</span><br><span class="line">trampoline_instructions[trampoline_pos++] = 0xe51ff004;</span><br><span class="line">trampoline_instructions[trampoline_pos++] = lr;</span><br></pre></td></tr></table></figure></p>
<p>Thumb指令的修正，大家可以参考这里的思路，自行阅读源码。</p>
<h2 id="线程处理"><a href="#线程处理" class="headerlink" title="线程处理"></a>线程处理</h2><p>一个完善的Inline Hook方案必须要考虑多线程环境，即要考虑线程恰好执行到被修改指令的位置。在Window下，使用<code>GetThreadContext</code>和<code>SetThreadContext</code>枚举所有线程，迁移context到搬迁后的指令中。然而在Linux+Arm环境下，并没有直接提供相同功能的API，不过可以使用<code>ptrace</code>完成，主要流程如下：</p>
<blockquote>
<ol>
<li>解析/proc/self/task目录，获取所有线程id</li>
<li>创建子进程，父进程等待。子进程枚举所有线程，PTRACE_ATTACH线程，迁移线程PC寄存器，枚举完毕后，子进程给自己发SIGSTOP信号，等待父进程唤醒</li>
<li>父进程检测到子进程已经SIGSTOP，完成Inline Hook工作，向子进程发送SIGCONT信号，同时等待子进程退出</li>
<li>子进程枚举所有线程，PTRACE_DETACH线程，枚举完毕后，子进程退出</li>
<li>父进程继续其他工作</li>
</ol>
</blockquote>
<p>这里使用子进程完成线程处理工作，实际上是迫不得已的。因为，如果直接使用本进程<code>PTRACE_ATTACH</code>线程，会出现<strong>operation not permitted</strong>，即使赋予root权限也是同样的错误，具体原因不得而知。<br>具体代码请参考<code>freeze</code>与<code>unFreeze</code>两个函数。</p>
<h2 id="其他一些细节"><a href="#其他一些细节" class="headerlink" title="其他一些细节"></a>其他一些细节</h2><ol>
<li>页保护<br>页面大小为4096字节，使用<code>mprotect</code>函数修改页面属性，修改为<code>PROT_READ | PROT_WRITE | PROT_EXEC</code>。</li>
<li>刷新缓存<br>对于ARM处理器来说，缓存机制作用明显，内存中的指令已经改变，但是cache中的指令可能仍为原有指令，所以需要手动刷新cache中的内容。采用<code>cacheflush</code>即可实现。</li>
<li>一个已知的BUG<br>虽然本库已经把大部分工作放在了<code>registerInlineHook</code>函数中，但是在<code>inlineHook</code>、<code>inlineUnHook</code>函数中还是不可避免的使用了部分libc库的API函数，例如：<code>mprotect</code>、<code>memcpy</code>、<code>munmap</code>、<code>free</code>、<code>cacheflush</code>等。如果使用本库对上述API函数进行Hook，可能会失败甚至崩溃，这是因为此时原函数的指令已经被破坏，或者其逻辑已经改变。解决这个Bug有两个方案，第一是采用其他Hook技术；第二将本库中的这些API函数全部采用内部实现，即不依赖于libc库，可采用静态链接libc库，或者使用汇编直接调相应的系统调用号。</li>
</ol>
</div></article></div></section><footer><div class="paginator"><a href="/0ctf-2016-boomshakalaka-writeup.html" class="prev">PREV</a><a href="/Analysis-Of-Backtrace-And-Inline-Hook-Thread-Safety-On-The-ARM-Platform.html" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'ele7enxxh';
var disqus_identifier = 'Android-Arm-Inline-Hook.html';
var disqus_title = 'Android Arm Inline Hook';
var disqus_url = 'http://ele7enxxh.com/Android-Arm-Inline-Hook.html';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//ele7enxxh.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2016 <a href="http://ele7enxxh.com">ele7enxxh</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?e9925f9b47e12674b38b04ce3cde49e6";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></body></html>